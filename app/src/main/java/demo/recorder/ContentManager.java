/*
 * Copyright 2013 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package demo.recorder;

import android.content.Context;
import android.graphics.BitmapFactory;
import android.os.AsyncTask;
import android.util.Log;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;

import demo.recorder.media.video.Content;
import demo.recorder.media.video.MovieTitles;
import demo.recorder.media.video.MovieTrailer;
import demo.recorder.media.video.SurfaceMovie;
import demo.recorder.util.BitmapHelper;

/**
 * Manages content generated by the app.
 * <p>
 * [ Originally this was going to prepare stuff on demand, but it's easier to just
 * create it all up front on first launch. ]
 * <p>
 * Class is thread-safe.
 */
public class ContentManager {
    private static final String TAG = "ContentManager";

    // Enumerated content tags.  These are used as indices into the mContent ArrayList,
    // so don't make them sparse.
    // TODO: consider using String tags and a HashMap?  prepare() is currently fragile,
    //       depending on the movies being added in tag-order.  Could also just use a plain array.
    public static final int MOVIE_TITLES = 0;

    public static final int MOVIE_TRAILER = 1;

    public static final int OK = 1;

    public static final int ERROR = 0;

    private static final int[] ALL_TAGS = new int[] {
            MOVIE_TITLES,
            MOVIE_TRAILER
    };

    // Housekeeping.
    private static final Object sLock = new Object();

    private static ContentManager sInstance = null;

    private boolean mInitialized = false;
    private File mFilesDir;
    private ArrayList<Content> mContent;
    private Context mContext;


    /**
     * Returns the singleton instance.
     */
    public static ContentManager getInstance() {
        synchronized (sLock) {
            if (sInstance == null) {
                sInstance = new ContentManager();
            }
            return sInstance;
        }
    }

    private ContentManager() {}

    public static void initialize(Context context) {
        ContentManager mgr = getInstance();
        synchronized (sLock) {
            if (!mgr.mInitialized) {
                mgr.mFilesDir = context.getFilesDir();
                mgr.mContent = new ArrayList<Content>();
                mgr.mInitialized = true;
                mgr.mContext = context;
            }
        }
    }

    /**
     * Returns true if all of the content has been created.
     * <p>
     * If this returns false, call createAll.
     */
    public boolean isContentCreated(@SuppressWarnings("unused") Context unused) {
        // Ideally this would probe each individual item to see if anything needs to be done,
        // and a subsequent "prepare" call would generate only the necessary items.  This
        // takes a much simpler approach and just checks to see if the files exist.  If the
        // content changes the user will need to force a regen (via a menu option) or wipe data.

        for (int i = 0; i < ALL_TAGS.length; i++) {
            File file = getPath(i);
            if (!file.canRead()) {
                Log.d(TAG, "Can't find readable " + file);
                return false;
            }
        }
        return true;
    }

    /**
     * Creates all content, overwriting any existing entries.
     * <p>
     * Call from main UI thread.
     */
    public void createAll(ICallBack callBack) {
        prepareContent(ALL_TAGS,callBack);
    }

    /**
     * Prepares the specified content.  For example, if the caller requires a movie that doesn't
     * exist, this will post a progress dialog and generate the movie.
     * <p>
     * Call from main UI thread.  This returns immediately.  Content generation continues
     * on a background thread.
     */
    public void prepareContent(int[] tags, ICallBack callBack) {
        // Generate content in async task.
        GenerateTask genTask = new GenerateTask( tags,callBack);
        genTask.execute();
    }

    /**
     * Returns the specified item.
     */
    public Content getContent(int tag) {
        synchronized (mContent) {
            return mContent.get(tag);
        }
    }

    /**
     * Prepares the specified item.
     * <p>
     * This may be called from the async task thread.
     */
    private void prepare(int tag) {
        SurfaceMovie movie;
        switch (tag) {
            case MOVIE_TITLES:
                movie = new MovieTitles();
                movie.setBitmap(BitmapHelper.createBitmap(mContext,"texture/test.png"));
                movie.generateMovie(getPath(tag));
                synchronized (mContent) {
                    mContent.add(tag, movie);
                }
                break;
            case MOVIE_TRAILER:
                movie = new MovieTrailer();
                movie.setBitmap(BitmapHelper.createBitmap(mContext,"texture/fengj.png"));
                movie.generateMovie(getPath(tag));
                synchronized (mContent) {
                    mContent.add(tag, movie);
                }
                break;
            default:
                throw new RuntimeException("Unknown tag " + tag);
        }
    }

    /**
     * Returns the filename for the tag.
     */
    public String getFileName(int tag) {
        switch (tag) {
            case MOVIE_TITLES:
                return "titles.mp4";
            case MOVIE_TRAILER:
                return "trailer.mp4";
            default:
                throw new RuntimeException("Unknown tag " + tag);
        }
    }

    /**
     * Returns the storage location for the specified item.
     */
    public File getPath(int tag) {
        return new File(mFilesDir, getFileName(tag));
    }

    public interface ICallBack {
        void onCompleted(int aReuslt,String aMessage);
    }

    /**
     * Performs generation of content on an async task thread.
     */
    private static class GenerateTask extends AsyncTask<Void, Integer, Integer> {
        private final int[] mTags;
        private volatile RuntimeException mFailure;
        private ICallBack mCallback;


        public GenerateTask(int[] tags,ICallBack aCallback) {
            mTags = tags;
            mCallback = aCallback;
        }

        @Override // async task thread
        protected Integer doInBackground(Void... params) {
            ContentManager contentManager = ContentManager.getInstance();

            Log.d(TAG, "doInBackground...");
            for (int i = 0; i < mTags.length; i++) {
                try {
                    contentManager.prepare( mTags[i]);
                } catch (RuntimeException re) {
                    mFailure = re;
                    break;
                }
            }

            if (mFailure != null) {
                Log.w(TAG, "Failed while generating content", mFailure);
                publishProgress(ContentManager.ERROR);
            } else {
                Log.d(TAG, "generation complete");
                publishProgress(ContentManager.OK);
            }
            return 0;
        }

        @Override // UI thread
        protected void onProgressUpdate(Integer... progressArray) {
            Log.d(TAG, "progress " +  + progressArray[0]);
        }

        @Override // UI thread
        protected void onPostExecute(Integer result) {
            Log.d(TAG, "onPostExecute");
            String aMessage = null;
            if (mFailure != null){
                aMessage = mFailure.getMessage();
            }
            mCallback.onCompleted(result,aMessage);
        }

    }
}
